generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                 String            @id @default(uuid())
  email              String
  fullName           String
  cpf                String            @unique
  birthday           DateTime
  cellphone          String
  religion           String?
  notes              String?
  createdAt          DateTime          @default(now())
  updateAt           DateTime          @updatedAt
  city               String
  diabetes           Boolean
  emergencyContact   String?
  hypertensive       Boolean
  indicatedBy        String?
  leadershipPosition String?
  profession         String
  profilePhotoUrl    String?
  role               Int               @default(5)
  state              String
  worker             Boolean
  registrationNumber Int               @unique @default(autoincrement())
  neighborhood       String
  badgeName          String?
  password           String            @default("$2b$10$QGF/lucztAy.bqQFEQcSOOjP3fGMZfSsCIl4t.dfFo15Hh0v/C8xW")
  bedrooms           BedroomsOnUsers[]
  events             EventOnUsers[]
  TeamOnUsers        TeamOnUsers[]
  waitlists          Waitlist[]

  @@map("users")
}

model Event {
  id         String         @id @default(uuid())
  name       String
  startDate  DateTime
  endDate    DateTime
  createdAt  DateTime       @default(now())
  updateAt   DateTime       @updatedAt
  isActive   Boolean        @default(false)
  groupLink  String?
  type       EventType      @default(CURSILHO)
  data       Json?
  users      EventOnUsers[]
  bedrooms   Bedrooms[]
  groupRoles GroupRoles[]
  Team       Team[]
  waitlist   Waitlist[]

  @@map("events")
}

model EventOnUsers {
  userId            String
  eventId           String
  createdAt         DateTime                        @default(now())
  updatedAt         DateTime                        @updatedAt
  event             Event                           @relation(fields: [eventId], references: [id])
  user              User                            @relation(fields: [userId], references: [id])
  rolesRegistration EventOnUsersRolesRegistration[] @relation("EventOnUsersRoles")

  @@id([userId, eventId])
}

model EventOnUsersRolesRegistration {
  userId             String
  eventId            String
  roleRegistrationId String
  discountId         String?
  discount           Discounts?        @relation(fields: [discountId], references: [id])
  role               RolesRegistration @relation(fields: [roleRegistrationId], references: [id], onDelete: Cascade)
  eventOnUsers       EventOnUsers      @relation("EventOnUsersRoles", fields: [userId, eventId], references: [userId, eventId], onDelete: Cascade)
  payment            Payment?

  @@id([userId, eventId, roleRegistrationId])
}

model GroupRoles {
  id       String              @id @default(uuid())
  name     String
  capacity Int?
  eventId  String
  event    Event               @relation(fields: [eventId], references: [id], onDelete: Cascade)
  roles    RolesRegistration[]

  @@map("group_roles")
}

model RolesRegistration {
  id           String                          @id @default(uuid())
  price        Float
  description  String
  groupId      String
  EventOnUsers EventOnUsersRolesRegistration[]
  group        GroupRoles                      @relation(fields: [groupId], references: [id], onDelete: Cascade)
  Waitlist     Waitlist[]

  @@map("roles_registration_types")
}

model Discounts {
  id          String                          @id @default(uuid())
  percentage  Float
  description String
  createdAt   DateTime                        @default(now())
  updatedAt   DateTime                        @updatedAt
  registers   EventOnUsersRolesRegistration[]

  @@map("discounts")
}

model Payment {
  id                 String                         @id @default(uuid())
  method             PaymentMethod
  status             PaymentStatus
  receivedFrom       PaymentReceived                @default(SYSTEM)
  amount             Float
  createdAt          DateTime                       @default(now())
  updatedAt          DateTime                       @updatedAt
  eventId            String?
  roleRegistrationId String?
  userId             String?
  payload            Json?
  checkouts          PaymentCheckout[]
  eventUserRole      EventOnUsersRolesRegistration? @relation(fields: [userId, eventId, roleRegistrationId], references: [userId, eventId, roleRegistrationId], onDelete: Cascade)

  @@unique([userId, eventId, roleRegistrationId])
  @@map("payments")
}

model PaymentCheckout {
  id          String         @id @default(uuid())
  paymentId   String
  checkoutId  String
  referenceId String
  status      CheckoutStatus
  amount      Float
  link        String
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  payment     Payment        @relation(fields: [paymentId], references: [id], onDelete: Cascade)

  @@map("payment_checkouts")
}

model Waitlist {
  id                 String             @id @default(uuid())
  userId             String
  eventId            String
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt
  roleRegistrationId String?
  event              Event              @relation(fields: [eventId], references: [id])
  rolesRegistration  RolesRegistration? @relation(fields: [roleRegistrationId], references: [id])
  user               User               @relation(fields: [userId], references: [id])

  @@unique([userId, eventId, roleRegistrationId])
  @@map("waitlist")
}

model Bedrooms {
  id       String            @id @default(uuid())
  note     String?
  eventId  String
  capacity Int?
  name     String            @default("Quarto sem nome")
  tag      String[]
  users    BedroomsOnUsers[]
  event    Event             @relation(fields: [eventId], references: [id])

  @@map("bedrooms")
}

model BedroomsOnUsers {
  userId     String
  bedroomsId String
  bedrooms   Bedrooms @relation(fields: [bedroomsId], references: [id])
  user       User     @relation(fields: [userId], references: [id])

  @@id([userId, bedroomsId])
}

model Team {
  id       String        @id @default(uuid())
  name     String
  eventId  String
  capacity Int?
  note     String?
  users    TeamOnUsers[]
  event    Event         @relation(fields: [eventId], references: [id])

  @@map("teams")
}

model TeamOnUsers {
  userId String
  teamId String
  role   TeamRole @default(MEMBER)
  team   Team     @relation(fields: [teamId], references: [id])
  user   User     @relation(fields: [userId], references: [id])

  @@id([userId, teamId])
}

model Log {
  id        String   @id @default(uuid())
  model     String   // nome da tabela (ex: User, Order, Map)
  action    String   // create | update | delete
  entityId  String?  // id do registro afetado
  before    Json?    // estado anterior
  after     Json?    // estado posterior
  userId    String?  // se quiser relacionar ao usu√°rio
  createdAt DateTime @default(now())

  @@map("logs")
}

enum TeamRole {
  MEMBER
  LEADER
}

enum EventType {
  CURSILHO
  RETIRO
}

enum PaymentReceived {
  SYSTEM
  EXTERNAL
}

enum PaymentMethod {
  PIX
  CREDIT_CARD
  DEBIT_CARD
  CASH
  BOLETO
  OTHER
}

enum PaymentStatus {
  PAID
  IN_ANALYSIS
  DECLINED
  CANCELED
  WAITING
  REFUNDED
}

enum CheckoutStatus {
  ACTIVE
  EXPIRED
  INACTIVE
}
